@page "/appointment"

@using MudBlazor
@using Blazored.SessionStorage
@using ConsulatTermine.Application.DTOs
@using ConsulatTermine.Application.Interfaces

@inject ISessionStorageService Session
@inject IAppointmentService AppointmentService
@inject IServiceService ServiceService
@inject NavigationManager Navigation

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-6">

    <!-- STEPPER -->
    <MudStepper Elevation="0" ActiveStep="1" Class="mb-6">
        <MudStep Label="Services" Completed="true" />
        <MudStep Label="Termine" />
        <MudStep Label="Formular" />
        <MudStep Label="Bestätigung" />
    </MudStepper>

    <MudPaper Class="pa-6" Style="border-radius:12px">

        @if (!_isReady)
        {
            <MudProgressLinear Indeterminate />
            <MudText Class="mt-3">Lade Daten…</MudText>
        }
        else
        {
            <MudGrid Spacing="3">

                <!-- LEFT: CALENDAR -->
                <MudItem xs="12" md="4">
                    <MudPaper Class="pa-4" Style="border-radius:12px">

                        <MudDatePicker
                            PickerVariant="PickerVariant.Static"
                            OpenTo="OpenTo.Date"
                            Color="Color.Success"
                            Date="_selectedDate"
                            DateChanged="@(EventCallback.Factory.Create<DateTime?>(this, HandleDateChanged))"
                            PickerMonthChanged="@(EventCallback.Factory.Create<DateTime?>(this, HandleMonthChanged))"
                            IsDateDisabledFunc="IsDateDisabled" />

                        <MudText Typo="Typo.caption" Class="mt-2" Style="opacity:.8">
                            Tage ohne verfügbare Termine sind nicht auswählbar.
                        </MudText>

                    </MudPaper>
                </MudItem>

                <!-- RIGHT: SLOTS -->
                <MudItem xs="12" md="8">
                    <MudPaper Class="pa-4" Style="border-radius:12px">

                        <MudText Typo="Typo.h5" Align="Align.Center" Color="Color.Success">
                            Termine für: @_currentServiceName
                        </MudText>

                        <MudText Typo="Typo.body2" Align="Align.Center" Class="mb-2">
                            Slot-Dauer: @_currentSlotDuration Minuten
                        </MudText>

                        <MudText Typo="Typo.body2" Align="Align.Center" Class="mb-4" Color="Color.Success">
                            Ausgewählt: @SelectedCountForCurrentService / @_requiredCountForCurrentService
                            @if (_requiredCountForCurrentService > 1)
                            {
                                <span> – noch @(Math.Max(0, _requiredCountForCurrentService - SelectedCountForCurrentService)) auswählen</span>
                            }
                        </MudText>

                        @if (_selectedDate == null)
                        {
                            <MudAlert Severity="Severity.Info">
                                Bitte wählen Sie zuerst einen Tag aus.
                            </MudAlert>
                        }
                        else if (_slots.Count == 0)
                        {
                            <MudAlert Severity="Severity.Info">
                                Keine freien Slots für diesen Tag.
                            </MudAlert>
                        }
                        else
                        {
                            <MudGrid Spacing="2">
                                @foreach (var slot in _slots)
                                {
                                    var slotStart = slot.SlotStart;

                                    <MudItem xs="12" sm="6">
                                        <MudPaper Class="pa-2" Style="border-radius:999px">

                                            <MudStack Direction="Row" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">

                                                <!-- LEFT: time + (optional capacity) -->
                                                <MudText Typo="Typo.subtitle1" Style="font-weight:600;">
                                                    @slotStart.ToString("HH:mm")
                                                    @if (_requiredCountForCurrentService > 1)
                                                    {
                                                        <span style="opacity:.8"> (@DisplayFreeCapacity(slot) frei)</span>
                                                    }
                                                </MudText>

                                                <!-- RIGHT: selection UI -->
                                                @if (_requiredCountForCurrentService == 1)
                                                {
                                                    <MudButton
                                                        Disabled="@(DisplayFreeCapacity(slot) <= 0)"
                                                        Variant="Variant.Outlined"
                                                        Color="Color.Primary"
                                                        OnClick="@(() => SelectSingleSlot(slot))"
                                                        Style="border-radius:999px; min-width:120px;">
                                                        @(IsSelected(slotStart) ? "Ausgewählt" : "Wählen")
                                                    </MudButton>
                                                }
                                                else
                                                {
                                                    <MudStack Direction="Row" Spacing="1" AlignItems="AlignItems.Center">

                                                        <MudIconButton
                                                            Icon="@Icons.Material.Filled.RemoveCircleOutline"
                                                            Disabled="@(GetCount(slotStart) <= 0)"
                                                            OnClick="@(() => Decrease(slot))" />

                                                        <MudText Typo="Typo.subtitle1" Style="min-width:26px; text-align:center;">
                                                            @GetCount(slotStart)
                                                        </MudText>

                                                        <MudIconButton
                                                            Icon="@Icons.Material.Filled.AddCircleOutline"
                                                            Disabled="@(GetCount(slotStart) >= DisplayFreeCapacity(slot) || SelectedCountForCurrentService >= _requiredCountForCurrentService)"
                                                            OnClick="@(() => Increase(slot))" />

                                                    </MudStack>
                                                }

                                            </MudStack>

                                        </MudPaper>
                                    </MudItem>
                                }
                            </MudGrid>
                        }

                        <MudDivider Class="my-4" />

                        <!-- Buttons -->
                        <MudStack Direction="Row" Spacing="2">

                            <MudButton Variant="Variant.Outlined" OnClick="Back">
                                ZURÜCK
                            </MudButton>

                            <MudButton
                                Variant="Variant.Filled"
                                Color="Color.Success"
                                Disabled="@(!CanGoNext)"
                                OnClick="Next">
                                WEITER
                            </MudButton>

                        </MudStack>

                        @if (_servicesOrdered.Count > 1)
                        {
                            <MudText Typo="Typo.caption" Class="mt-3" Style="opacity:.8">
                                Service @(_serviceIndex + 1) / @_servicesOrdered.Count
                            </MudText>
                        }

                    </MudPaper>
                </MudItem>

            </MudGrid>
        }

    </MudPaper>
</MudContainer>

@code {

    // ===========================
    // CONFIG
    // ===========================
    private static readonly TimeSpan BufferTime = TimeSpan.FromMinutes(60);

    // ===========================
    // READY / INIT
    // ===========================
    private bool _isReady;

    // Session input
    private int _personCount;
    private Dictionary<int, int> _serviceAssignments = new();

    // Service flow
    private List<int> _servicesOrdered = new();
    private int _serviceIndex;

    // Current service meta
    private int _currentServiceId;
    private string _currentServiceName = "";
    private int _currentSlotDuration; // minutes
    private int _requiredCountForCurrentService;

    // Calendar
    private DateOnly _currentMonth; // first day of month
    private DateTime? _selectedDate;

    private Dictionary<DateOnly, bool> _bookableCache = new(); // month cache

    // Slots
    private List<AvailableSlotDto> _slots = new();

    // Allocation: serviceId -> slotStart -> count
    private Dictionary<int, Dictionary<DateTime, int>> _allocations = new();

    // Duration cache (serviceId -> slotDurationMinutes)
    private Dictionary<int, int> _serviceDurationById = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        await InitFromSessionAsync();
        _isReady = true;
        StateHasChanged();
    }

    private async Task InitFromSessionAsync()
    {
        _personCount = await Session.GetItemAsync<int>("personCount");
        _serviceAssignments = await Session.GetItemAsync<Dictionary<int, int>>("serviceAssignments")
                              ?? new Dictionary<int, int>();

        if (_serviceAssignments.Count == 0)
        {
            Navigation.NavigateTo("/services");
            return;
        }

        // Deterministic order (IDs asc)
        _servicesOrdered = _serviceAssignments.Keys.OrderBy(x => x).ToList();
        _serviceIndex = 0;

        // init allocations store
        foreach (var sid in _servicesOrdered)
            _allocations[sid] = new Dictionary<DateTime, int>();

        // Start at today month (neutral)
        var now = DateTime.Today;
        _currentMonth = new DateOnly(now.Year, now.Month, 1);

        await LoadCurrentServiceAsync();
        await LoadMonthAvailabilityAsync(_currentMonth);

        // IMPORTANT: do not preselect a day
        _selectedDate = null;
        _slots = new List<AvailableSlotDto>();
    }

    // ===========================
    // SERVICE STEP
    // ===========================
    private async Task LoadCurrentServiceAsync()
    {
        _currentServiceId = _servicesOrdered[_serviceIndex];
        _requiredCountForCurrentService = _serviceAssignments[_currentServiceId];

        // Use existing IServiceService method
        var dto = await ServiceService.GetByIdAsync(_currentServiceId);

        _currentServiceName = dto.Name;
        _currentSlotDuration = dto.SlotDurationMinutes;

        // cache duration
        _serviceDurationById[_currentServiceId] = _currentSlotDuration;

        // ✅ FIX (Problem 1): Service-Wechsel darf kein Datum erzwingen
        _selectedDate = null;
        _slots.Clear();
    }

    // ===========================
    // DATE PICKER EVENTS
    // ===========================
    private async Task HandleMonthChanged(DateTime? date)
    {
        if (!date.HasValue) return;

        _currentMonth = new DateOnly(date.Value.Year, date.Value.Month, 1);

        await LoadMonthAvailabilityAsync(_currentMonth);

        _selectedDate = null;
        _slots.Clear();
        StateHasChanged();
    }

    private async Task HandleDateChanged(DateTime? date)
    {
        _selectedDate = date;

        if (!_selectedDate.HasValue)
        {
            _slots.Clear();
            StateHasChanged();
            return;
        }

        var day = DateOnly.FromDateTime(_selectedDate.Value);

        // Safety: ignore disabled day
        if (!_bookableCache.TryGetValue(day, out var ok) || !ok)
        {
            _selectedDate = null;
            _slots.Clear();
            StateHasChanged();
            return;
        }

        await LoadSlotsForSelectedDayAsync(day);
        StateHasChanged();
    }

    private bool IsDateDisabled(DateTime date)
    {
        var d = DateOnly.FromDateTime(date);
        return !_bookableCache.TryGetValue(d, out var ok) || !ok;
    }

    // ===========================
    // BACKEND LOADS
    // ===========================
    private async Task LoadMonthAvailabilityAsync(DateOnly monthFirstDay)
    {
        _bookableCache.Clear();

        int days = DateTime.DaysInMonth(monthFirstDay.Year, monthFirstDay.Month);
        for (int d = 1; d <= days; d++)
        {
            var date = new DateOnly(monthFirstDay.Year, monthFirstDay.Month, d);

            var raw = await AppointmentService.GetAvailableSlotDtosAsync(
                _currentServiceId,
                date.ToDateTime(TimeOnly.MinValue));

            // ✅ FIX (Problem 2): Bookable wenn irgendein Slot zeitlich kompatibel ist (vor ODER nach)
            var otherSelected = BuildOtherSelectedSlotsForCompatibility();

            bool anyValid = raw.Any(s =>
                s.FreeCapacity > 0 &&
                AppointmentCalculator.IsSlotTimeCompatible(
                    s.SlotStart,
                    _currentSlotDuration,
                    otherSelected,
                    BufferTime));

            _bookableCache[date] = anyValid;
        }
    }

    private async Task LoadSlotsForSelectedDayAsync(DateOnly day)
    {
        var raw = await AppointmentService.GetAvailableSlotDtosAsync(
            _currentServiceId,
            day.ToDateTime(TimeOnly.MinValue));

        var otherSelected = BuildOtherSelectedSlotsForCompatibility();

        // ✅ FIX (Problem 2): Filter symmetrisch (vor ODER nach) – nicht nur "ab earliest"
        _slots = raw
            .Where(x => x.FreeCapacity > 0)
            .Where(x => AppointmentCalculator.IsSlotTimeCompatible(
                x.SlotStart,
                _currentSlotDuration,
                otherSelected,
                BufferTime))
            .OrderBy(x => x.SlotStart)
            .ToList();
    }

    // Builds list of other selected slots as (Start, DurationMinutes)
    private List<(DateTime Start, int DurationMinutes)> BuildOtherSelectedSlotsForCompatibility()
    {
        var list = new List<(DateTime Start, int DurationMinutes)>();

        foreach (var sid in _servicesOrdered)
        {
            if (sid == _currentServiceId)
                continue;

            if (!_serviceDurationById.TryGetValue(sid, out var dur))
                continue;

            var map = _allocations[sid];

            foreach (var kvp in map)
            {
                var slotStart = kvp.Key;
                var count = kvp.Value;

                if (count <= 0) continue;

                // add "count" times to reflect multiple persons on same slot
                for (int i = 0; i < count; i++)
                    list.Add((slotStart, dur));
            }
        }

        return list;
    }

    // ===========================
    // SLOT SELECTION LOGIC
    // ===========================
    private int SelectedCountForCurrentService
        => _allocations[_currentServiceId].Values.Sum();

    private bool IsSelected(DateTime slotStart)
        => _allocations[_currentServiceId].TryGetValue(slotStart, out var c) && c > 0;

    private int GetCount(DateTime slotStart)
        => _allocations[_currentServiceId].TryGetValue(slotStart, out var c) ? c : 0;

    private int DisplayFreeCapacity(AvailableSlotDto slot)
    {
        // UI zeigt "frei" dynamisch: backend free - already selected on same slot for this service
        var selectedOnThisSlot = GetCount(slot.SlotStart);
        return Math.Max(0, slot.FreeCapacity - selectedOnThisSlot);
    }

    private void SelectSingleSlot(AvailableSlotDto slot)
    {
        var map = _allocations[_currentServiceId];
        map.Clear();
        map[slot.SlotStart] = 1;
    }

    private void Increase(AvailableSlotDto slot)
    {
        var map = _allocations[_currentServiceId];
        var current = GetCount(slot.SlotStart);

        if (SelectedCountForCurrentService >= _requiredCountForCurrentService) return;
        if (current >= DisplayFreeCapacity(slot)) return;

        map[slot.SlotStart] = current + 1;
    }

    private void Decrease(AvailableSlotDto slot)
    {
        var map = _allocations[_currentServiceId];
        var current = GetCount(slot.SlotStart);
        if (current <= 0) return;

        var next = current - 1;
        if (next == 0) map.Remove(slot.SlotStart);
        else map[slot.SlotStart] = next;
    }

    // ===========================
    // NAVIGATION
    // ===========================
    private bool CanGoNext
        => SelectedCountForCurrentService == _requiredCountForCurrentService;

    private void Back()
    {
        if (_serviceIndex > 0)
        {
            _serviceIndex--;
            _ = GoToServiceIndexAsync(_serviceIndex);
        }
        else
        {
            Navigation.NavigateTo("/services");
        }
    }

    private async Task Next()
    {
        if (!CanGoNext)
            return;

        await SaveSelectionsToSessionAsync();

        if (_serviceIndex < _servicesOrdered.Count - 1)
        {
            _serviceIndex++;
            await GoToServiceIndexAsync(_serviceIndex);
        }
        else
        {
            Navigation.NavigateTo("/appointment-form");
        }
    }

    private async Task GoToServiceIndexAsync(int index)
    {
        _serviceIndex = index;

        await LoadCurrentServiceAsync();

        // Keep month as user is viewing, but refresh availability for the new service
        await LoadMonthAvailabilityAsync(_currentMonth);

        // IMPORTANT: no date carry-over across services
        _selectedDate = null;
        _slots.Clear();

        StateHasChanged();
    }

    private async Task SaveSelectionsToSessionAsync()
    {
        // Expand allocations into serviceId -> List<DateTime> (repeated per person)
        var expanded = new Dictionary<int, List<DateTime>>();

        foreach (var sid in _servicesOrdered)
        {
            var list = new List<DateTime>();
            foreach (var kv in _allocations[sid].OrderBy(x => x.Key))
            {
                for (int i = 0; i < kv.Value; i++)
                    list.Add(kv.Key);
            }
            expanded[sid] = list;
        }

        await Session.SetItemAsync("selectedServiceSlots", expanded);
    }
}